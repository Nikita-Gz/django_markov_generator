import random
import re

from typing import Tuple
from collections import defaultdict

from .text_preprocessing import normal_preprocessing

def create_frequency_table(words: list,
                           max_key_length: int,
                           use_all_key_lengths: bool) -> dict:
  """
  Creates dict of dicts of ints, specifying the frequency (int) at which
  several words (first key) are followed by another word (nested dict key).

  :param words: list of consecutive separate words in a text.
  :param max_key_length: specifies the maximum length (in words) of the first key.
  :param use_all_key_lengths: specifies whether the the first keys should contain
  only the maximum amount of words allowed (max_key_length), or all amounts up to
  and including the max_key_length.
  NOTE: this hugely increases the returned dict size, values above 4 are not recommended
  :return: dictionary of dictionaries of ints. First key is the word sequence,
  nested dict key is the following word, int is the frequency.
  """

  # use defaultdict to create dicts on access
  table = defaultdict(dict)

  if use_all_key_lengths:
    used_key_lengths = [i + 1 for i in range(max_key_length)]
  else:
    used_key_lengths = [max_key_length]

  # pass the text for each used key length
  for key_length in used_key_lengths:

    # add to the table the frequency of each word sequence in the text being
    # followed by the next word
    for position, _ in enumerate(words[:-key_length]):

      # extract the preceding word sequence
      key = ' '.join(words[position : position + key_length])

      # extract the word after the sequence
      next_word = words[position + key_length]

      next_word = next_word.strip()

      next_word_occurances = table[key].get(next_word, 0)
      table[key][next_word] = next_word_occurances + 1

  # convert from defaultdict to dict
  table = dict(table)
  return table


# returns generated text, selected prompt, and a reason for stopping generation
def generate(table: dict, prompt: str, max_text_length: int,
             max_used_key_length: int, remove_numbers: bool,
             split_by_punctuation: bool) -> Tuple[str, str, str]:
  """
  Generates and returns text, selected prompt, and reason for stopping
  :param table: frequency table generated by create_frequency_table
  :param prompt: text prompt to use, can be empty for a random prompt
  :param max_text_length: maximum allowed length of the generated text
  :param max_used_key_length: maximum key length to use when generating text
  :param remove_numbers: whether to remove numbers when processing custom prompt
  :param split_by_punctuation: whether to split custom prompt by punctuation
  :return: returns generated string, selected (or randomly chosen) prompt, and
  a string describing the reason for stopping generation
  """
  # create prompt if there is none, prepare it if there is one and use it
  if prompt == '':
    # for a random prompt, select keys of maximum used key lengths,
    # then make a random choice between them
    keys = [key for key in table if len(key.split()) == max_used_key_length]
    selected_key = random.choice(keys)
    prompt = normal_preprocessing(selected_key,
                                  remove_numbers,
                                  split_by_punctuation)
  else:
    prompt = normal_preprocessing(prompt,
                                  remove_numbers,
                                  split_by_punctuation)
    if prompt == '':
      raise Exception('Bad prompt!')

  # todo: reduce prompt to the max used length before assigning it as key
  key = ' '.join(prompt)
  generated_words = prompt.copy()
  for i in range(max_text_length):

    # shorten the key by one word until it is either present in the
    # frequency table or is empty
    while key not in table:
      key = ' '.join(key.split()[1:])
      if key == '':
        return (' '.join(generated_words),
                ' '.join(prompt),
                'No next words could be generated')

    next_word = random.choices(list(table[key]), table[key].values())
    generated_words.append(next_word[0])

    # update key to use the next set of words
    key = ' '.join(generated_words[-max_used_key_length:])

  generated_words = fix_generated_punctuation(' '.join(generated_words))
  prompt = fix_generated_punctuation(' '.join(prompt))
  return generated_words, prompt, 'Reached the text length limit'


# matches space between a word and punctuation, like in "hello , friend"
r = r'\s[^\w\"\(\)]'
matcher = re.compile(r)
def fix_generated_punctuation(s: str) -> str:
  """ fixes strings like 'hello , friend' to 'hello, friend' """

  def replacer(match):
    return match.group().strip()

  s = matcher.sub(replacer, s)
  return s
